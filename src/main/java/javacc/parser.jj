/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. parser.jj */
/*@egen*/
/*
 * Copyright \u00c2\u00a9 2002 Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * California 95054, U.S.A. All rights reserved.  Sun Microsystems, Inc. has
 * intellectual property rights relating to technology embodied in the product
 * that is described in this document. In particular, and without limitation,
 * these intellectual property rights may include one or more of the U.S.
 * patents listed at http://www.sun.com/patents and one or more additional
 * patents or pending patent applications in the U.S. and in other countries.
 * U.S. Government Rights - Commercial software. Government users are subject
 * to the Sun Microsystems, Inc. standard license agreement and applicable
 * provisions of the FAR and its supplements.  Use is subject to license terms.
 * Sun,  Sun Microsystems,  the Sun logo and  Java are trademarks or registered
 * trademarks of Sun Microsystems, Inc. in the U.S. and other countries.  This
 * product is covered and controlled by U.S. Export Control laws and may be
 * subject to the export or import laws in other countries.  Nuclear, missile,
 * chemical biological weapons or nuclear maritime end uses or end users,
 * whether direct or indirect, are strictly prohibited.  Export or reexport
 * to countries subject to U.S. embargo or to entities identified on U.S.
 * export exclusion lists, including, but not limited to, the denied persons
 * and specially designated nationals lists is strictly prohibited.
 */


options {
  LOOKAHEAD = 17;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
  TOKEN_FACTORY = "Token";
             
               
                         
                          

}

PARSER_BEGIN(Parser)

package javacc;
public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/ 
  public static void main(String args[]) throws Exception {
  
  }

}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

TOKEN [IGNORE_CASE]:
{
    < GLOBAL: ("GLOBALLY"|"G")>
|   < FUTURE: ("FINALLY"|"EVENTUALLY"|"F")>
|   < NEXT: ("NEXT"|"X")>
|   < UNTIL: ("UNTIL"|"U")>
|   < ALL: ("ALL" | "A")>
|   < EXIST: "EXIST" | "E">
|   < LIVE: "LIVE" | "L">
|   < DEADLOCK: "DEADLOCK" | "D">
}

TOKEN:
{
    < AND: ("and"|"^"|"&") >
|   < OR: ("or"|"|") >
|   < NOT: ("not"|"~"|"!") >
}
 
TOKEN:
{
    < PLACE: <NAME> (<NUMBER>)? >
|   < NAME: (["a"-"z"])+ >
|   < NUMBER: (["0"-"9"])+ >
}


ASTStart Start()      : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Start */
                            try {
/*@egen*/(    MultiStatement()
                            |   Statement()
                            |/*@bgen(jjtree) Lstatement */
                                {
                                  ASTLstatement jjtn001 = new ASTLstatement(JJTLSTATEMENT);
                                  boolean jjtc001 = true;
                                  jjtree.openNodeScope(jjtn001);
                                }
                                try {
/*@egen*/   <LIVE>/*@bgen(jjtree)*/
                                } finally {
                                  if (jjtc001) {
                                    jjtree.closeNodeScope(jjtn001, true);
                                  }
                                }
/*@egen*/             
                            |/*@bgen(jjtree) Dstatement */
                                {
                                  ASTDstatement jjtn002 = new ASTDstatement(JJTDSTATEMENT);
                                  boolean jjtc002 = true;
                                  jjtree.openNodeScope(jjtn002);
                                }
                                try {
/*@egen*/   <DEADLOCK>/*@bgen(jjtree)*/
                                } finally {
                                  if (jjtc002) {
                                    jjtree.closeNodeScope(jjtn002, true);
                                  }
                                }
/*@egen*/              )/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/

{return jjtn000;}/*@bgen(jjtree)*/
                            } catch (Throwable jjte000) {
                              if (jjtc000) {
                                jjtree.clearNodeScope(jjtn000);
                                jjtc000 = false;
                              } else {
                                jjtree.popNode();
                              }
                              if (jjte000 instanceof RuntimeException) {
                                throw (RuntimeException)jjte000;
                              }
                              if (jjte000 instanceof ParseException) {
                                throw (ParseException)jjte000;
                              }
                              throw (Error)jjte000;
                            } finally {
                              if (jjtc000) {
                                jjtree.closeNodeScope(jjtn000, true);
                              }
                            }
/*@egen*/}

void Statement()          :{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Statement */
                                try {
/*@egen*/ (Not())? All()
                    |  (Not())? Exist()
                    |   State()/*@bgen(jjtree)*/
                                } catch (Throwable jjte000) {
                                  if (jjtc000) {
                                    jjtree.clearNodeScope(jjtn000);
                                    jjtc000 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte000 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte000;
                                  }
                                  if (jjte000 instanceof ParseException) {
                                    throw (ParseException)jjte000;
                                  }
                                  throw (Error)jjte000;
                                } finally {
                                  if (jjtc000) {
                                    jjtree.closeNodeScope(jjtn000, true);
                                  }
                                }
/*@egen*/
                    }

void MultiStatement()                : {/*@bgen(jjtree) MultiStatement */
  ASTMultiStatement jjtn000 = new ASTMultiStatement(JJTMULTISTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}   {/*@bgen(jjtree) MultiStatement */
                                             try {
/*@egen*/Statement() (And() Statement())+
                                         |   Statement() (Or() Statement())+/*@bgen(jjtree)*/
                                             } catch (Throwable jjte000) {
                                               if (jjtc000) {
                                                 jjtree.clearNodeScope(jjtn000);
                                                 jjtc000 = false;
                                               } else {
                                                 jjtree.popNode();
                                               }
                                               if (jjte000 instanceof RuntimeException) {
                                                 throw (RuntimeException)jjte000;
                                               }
                                               if (jjte000 instanceof ParseException) {
                                                 throw (ParseException)jjte000;
                                               }
                                               throw (Error)jjte000;
                                             } finally {
                                               if (jjtc000) {
                                                 jjtree.closeNodeScope(jjtn000, true);
                                               }
                                             }
/*@egen*/ }

void All()              : {/*@bgen(jjtree) AllStatement */
  ASTAllStatement jjtn000 = new ASTAllStatement(JJTALLSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) AllStatement */
                              try {
/*@egen*/<ALL> "(" State() ")"/*@bgen(jjtree)*/
                              } catch (Throwable jjte000) {
                                if (jjtc000) {
                                  jjtree.clearNodeScope(jjtn000);
                                  jjtc000 = false;
                                } else {
                                  jjtree.popNode();
                                }
                                if (jjte000 instanceof RuntimeException) {
                                  throw (RuntimeException)jjte000;
                                }
                                if (jjte000 instanceof ParseException) {
                                  throw (ParseException)jjte000;
                                }
                                throw (Error)jjte000;
                              } finally {
                                if (jjtc000) {
                                  jjtree.closeNodeScope(jjtn000, true);
                                }
                              }
/*@egen*/}

void Exist()            : {/*@bgen(jjtree) Estatement */
  ASTEstatement jjtn000 = new ASTEstatement(JJTESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Estatement */
                                 try {
/*@egen*/   <EXIST> "(" State() ")"
                            |   <EXIST> Places()/*@bgen(jjtree)*/
                                 } catch (Throwable jjte000) {
                                   if (jjtc000) {
                                     jjtree.clearNodeScope(jjtn000);
                                     jjtc000 = false;
                                   } else {
                                     jjtree.popNode();
                                   }
                                   if (jjte000 instanceof RuntimeException) {
                                     throw (RuntimeException)jjte000;
                                   }
                                   if (jjte000 instanceof ParseException) {
                                     throw (ParseException)jjte000;
                                   }
                                   throw (Error)jjte000;
                                 } finally {
                                   if (jjtc000) {
                                     jjtree.closeNodeScope(jjtn000, true);
                                   }
                                 }
/*@egen*/
                            }

void And()     : {/*@bgen(jjtree) And */
  ASTAnd jjtn000 = new ASTAnd(JJTAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) And */
                     try {
/*@egen*/<AND>/*@bgen(jjtree)*/
                     } finally {
                       if (jjtc000) {
                         jjtree.closeNodeScope(jjtn000, true);
                       }
                     }
/*@egen*/}

void Or()    : {/*@bgen(jjtree) Or */
  ASTOr jjtn000 = new ASTOr(JJTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Or */
                   try {
/*@egen*/<OR>/*@bgen(jjtree)*/
                   } finally {
                     if (jjtc000) {
                       jjtree.closeNodeScope(jjtn000, true);
                     }
                   }
/*@egen*/}

void Not()     : {/*@bgen(jjtree) Not */
  ASTNot jjtn000 = new ASTNot(JJTNOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Not */
                     try {
/*@egen*/<NOT>/*@bgen(jjtree)*/
                     } finally {
                       if (jjtc000) {
                         jjtree.closeNodeScope(jjtn000, true);
                       }
                     }
/*@egen*/}

void State(): {} { Next()   |Globally() |Finaly()   |Until()}

void Next()     : {/*@bgen(jjtree) Next */
  ASTNext jjtn000 = new ASTNext(JJTNEXT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}  {/*@bgen(jjtree) Next */
                         try {
/*@egen*/  Places () <NEXT> Places() |   <NEXT> Places()/*@bgen(jjtree)*/
                         } catch (Throwable jjte000) {
                           if (jjtc000) {
                             jjtree.clearNodeScope(jjtn000);
                             jjtc000 = false;
                           } else {
                             jjtree.popNode();
                           }
                           if (jjte000 instanceof RuntimeException) {
                             throw (RuntimeException)jjte000;
                           }
                           if (jjte000 instanceof ParseException) {
                             throw (ParseException)jjte000;
                           }
                           throw (Error)jjte000;
                         } finally {
                           if (jjtc000) {
                             jjtree.closeNodeScope(jjtn000, true);
                           }
                         }
/*@egen*/  }

void Globally()         : {/*@bgen(jjtree) Globally */
  ASTGlobally jjtn000 = new ASTGlobally(JJTGLOBALLY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}  {/*@bgen(jjtree) Globally */
                                 try {
/*@egen*/  Places () <GLOBAL> Places() |   <GLOBAL> Places()/*@bgen(jjtree)*/
                                 } catch (Throwable jjte000) {
                                   if (jjtc000) {
                                     jjtree.clearNodeScope(jjtn000);
                                     jjtc000 = false;
                                   } else {
                                     jjtree.popNode();
                                   }
                                   if (jjte000 instanceof RuntimeException) {
                                     throw (RuntimeException)jjte000;
                                   }
                                   if (jjte000 instanceof ParseException) {
                                     throw (ParseException)jjte000;
                                   }
                                   throw (Error)jjte000;
                                 } finally {
                                   if (jjtc000) {
                                     jjtree.closeNodeScope(jjtn000, true);
                                   }
                                 }
/*@egen*/  }

void Finaly()       : {/*@bgen(jjtree) Finaly */
  ASTFinaly jjtn000 = new ASTFinaly(JJTFINALY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}  {/*@bgen(jjtree) Finaly */
                             try {
/*@egen*/  Places () <FUTURE> Places() |   <FUTURE> Places()/*@bgen(jjtree)*/
                             } catch (Throwable jjte000) {
                               if (jjtc000) {
                                 jjtree.clearNodeScope(jjtn000);
                                 jjtc000 = false;
                               } else {
                                 jjtree.popNode();
                               }
                               if (jjte000 instanceof RuntimeException) {
                                 throw (RuntimeException)jjte000;
                               }
                               if (jjte000 instanceof ParseException) {
                                 throw (ParseException)jjte000;
                               }
                               throw (Error)jjte000;
                             } finally {
                               if (jjtc000) {
                                 jjtree.closeNodeScope(jjtn000, true);
                               }
                             }
/*@egen*/  }

void Until()      : {/*@bgen(jjtree) Until */
  ASTUntil jjtn000 = new ASTUntil(JJTUNTIL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}  {/*@bgen(jjtree) Until */
                           try {
/*@egen*/  Places () <UNTIL> Places()/*@bgen(jjtree)*/
                           } catch (Throwable jjte000) {
                             if (jjtc000) {
                               jjtree.clearNodeScope(jjtn000);
                               jjtc000 = false;
                             } else {
                               jjtree.popNode();
                             }
                             if (jjte000 instanceof RuntimeException) {
                               throw (RuntimeException)jjte000;
                             }
                             if (jjte000 instanceof ParseException) {
                               throw (ParseException)jjte000;
                             }
                             throw (Error)jjte000;
                           } finally {
                             if (jjtc000) {
                               jjtree.closeNodeScope(jjtn000, true);
                             }
                           }
/*@egen*/    }

void Places()        : {/*@bgen(jjtree) Places */
  ASTPlaces jjtn000 = new ASTPlaces(JJTPLACES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}  {/*@bgen(jjtree) Places */
                             try {
/*@egen*/ "[" Place() ( <AND> Place() )* "]" | Place()/*@bgen(jjtree)*/
                             } catch (Throwable jjte000) {
                               if (jjtc000) {
                                 jjtree.clearNodeScope(jjtn000);
                                 jjtc000 = false;
                               } else {
                                 jjtree.popNode();
                               }
                               if (jjte000 instanceof RuntimeException) {
                                 throw (RuntimeException)jjte000;
                               }
                               if (jjte000 instanceof ParseException) {
                                 throw (ParseException)jjte000;
                               }
                               throw (Error)jjte000;
                             } finally {
                               if (jjtc000) {
                                 jjtree.closeNodeScope(jjtn000, true);
                               }
                             }
/*@egen*/ }

void Place(): {}  {   <PLACE>/*@bgen(jjtree) placename */
                              {
                                ASTplacename jjtn001 = new ASTplacename(JJTPLACENAME);
                                boolean jjtc001 = true;
                                jjtree.openNodeScope(jjtn001);
                              }
                              try {
/*@egen*//*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn001, true);
                                jjtc001 = false;
                              }
/*@egen*/ {jjtn001.data.put("place",token.image);}/*@bgen(jjtree)*/
                              } finally {
                                if (jjtc001) {
                                  jjtree.closeNodeScope(jjtn001, true);
                                }
                              }
/*@egen*/          }